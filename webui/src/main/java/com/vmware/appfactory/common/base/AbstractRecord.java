/* ***********************************************************************
 * VMware ThinApp Factory
 * Copyright (c) 2009-2013 VMware, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ***********************************************************************/

package com.vmware.appfactory.common.base;

import java.util.List;

import javax.annotation.Nullable;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.MappedSuperclass;
import javax.validation.constraints.NotNull;

import com.vmware.thinapp.common.base.HasId;
import com.vmware.thinapp.common.util.AfCalendar;


/**
 * Base class used by all persistent objects. This provides common functionality
 * for any object that is stored to the database.
 */
@MappedSuperclass
public abstract class AbstractRecord
   implements HasId
{
   /** Default string length (matches the PostgreSQL default) */
   public static final int DEFAULT_LEN = 255;

   /** Usual length for long strings (descriptions, etc) */
   public static final int LONG_LEN = 4096;

   /** Truncate a string to the default length
    * @param str
    * @return */
   public static final String truncateDefault(String str) {
      return truncate(str, DEFAULT_LEN);
   }

   /** Truncate a string to the usual long length
    * @param str
    * @return */
   public static final String truncateLong(String str) {
      return truncate(str, LONG_LEN);
   }

   /** Truncate a string to a particular length
    * @param str
    * @param maxLen
    * @return */
   public static final String truncate(String str, int maxLen) {
      return
         str == null ? null :
         str.length() <= maxLen ? str :
            str.substring(0, maxLen);
   }


   @Id
   @GeneratedValue
   private Long _id;

   @NotNull
   private long _created = AfCalendar.NEVER;

   @NotNull
   private long _modified = AfCalendar.NEVER;


   /**
    * Default constructor.
    */
   public AbstractRecord()
   {
      /* Nothing to do */
   }


   /**
    * Copy constructor.
    * @param other
    */
   public AbstractRecord(AbstractRecord other)
   {
      _id = other._id;
      _created = other._created;
      _modified = other._modified;
   }


   /**
    * Get the record's Id. This is generated by the database when the record is
    * first saved.
    * @return
    */
   public Long getId()
   {
      return _id;
   }


   /**
    * Set the record's Id.
    * @param id
    */
   public void setId(@Nullable Long id)
   {
      _id = id;
   }


   /**
    * Set the time when the record was created. This is automatically set by the
    * methods in BaseDaoImpl.
    * @param created
    */
   public void setCreated(long created)
   {
      _created = created;
   }


   /**
    * Get the time when the record was created. This is automatically set by the
    * methods in BaseDaoImpl.
    * @return
    */
   public long getCreated()
   {
      return _created;
   }


   /**
    * Set the time when the record was last modified. This is automatically set
    * by the methods in BaseDaoImpl.
    * @param modified
    */
   public void setModified(long modified)
   {
      _modified = modified;
   }


   /**
    * Get the time when the record was modified. This is automatically set by
    * the methods in BaseDaoImpl.
    * @return
    */
   public long getModified()
   {
      return _modified;
   }


   /**
    * Perform a deep copy of all fields in this record.
    * @param other
    * @return The number of changes made.
    */
   public abstract int deepCopy(AbstractRecord other);


   /**
    * Check to see if one list is the same as the another list.
    * This is needed due to Hibernate adding a cut-point around List fields,
    * which changes the List to a Bag (which does not support equals() in the
    * way you would expect).
    *
    * @param list1
    * @param list2
    * @return
    */
   protected static boolean listsAreEqual(List<?> list1, List<?> list2)
   {
      if (list1.size() != list2.size()) {
         return false;
      }

      for (int i = 0; i < list1.size(); i++) {
         if (!list1.get(i).equals(list2.get(i))) {
            return false;
         }
      }

      return true;
   }

}
