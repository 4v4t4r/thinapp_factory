/* ***********************************************************************
 * VMware ThinApp Factory
 * Copyright (c) 2009-2013 VMware, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ***********************************************************************/

package com.vmware.appfactory.taskqueue.tasks.state.tasks;

import java.util.concurrent.Semaphore;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.vmware.appfactory.application.model.AppBuildRequest.RequestStage;
import com.vmware.appfactory.common.exceptions.AfNotFoundException;
import com.vmware.appfactory.manualmode.IManualModeService;
import com.vmware.appfactory.taskqueue.dto.CaptureRequest;
import com.vmware.appfactory.taskqueue.exception.TaskException;
import com.vmware.appfactory.taskqueue.tasks.TaskHelperFactory;
import com.vmware.appfactory.taskqueue.tasks.TaskQueue;
import com.vmware.appfactory.taskqueue.tasks.state.ManualModeState;
import com.vmware.thinapp.common.converter.dto.Project;
import com.vmware.thinapp.common.converter.dto.Status;
import com.vmware.thinapp.common.converter.dto.Status.State;
import com.vmware.thinapp.common.workpool.dto.Workpool;

/**
 * ManualModeTask is to track progress during manual mode build.
 * Unlike other tasks, this task never talks to CWS, but instead it invokes Manual mode
 * component directly.
 *
 * @author saung
 * @since v1.0 5/19/2011
 */
class ManualModeTask
      extends AbstractCaptureTask<ManualModeState,ManualModeState.Builder,ManualModeState.ManualModeStatus> {

   /** A semaphore with a single permit */
   private final Semaphore lock = new Semaphore(1);
   /* Taks description */
   private static final String TASK_DESCRIPTION = "Manual conversion of ";
   /* Manual mode service instance */
   private final IManualModeService _manualModeService;

   /**
    * Constructor
    * @param ticketId a ticket id generated by Manual mode's request.
    * @param manualModeService a manual mode service instance.
    * @param taskHelperFactory Accessor to other factory objects.
    * @param horizonUrl Horizon URL to configure captured project with
    * @param conversionsQueue queue to use when rebuilding
    */
   ManualModeTask(
           CaptureRequest captureRequest,
           Long ticketId,
           IManualModeService manualModeService,
           TaskHelperFactory taskHelperFactory,
           String horizonUrl,
           TaskQueue conversionsQueue) {
      super(taskHelperFactory, new ManualModeState.Builder()
            .withNewId(taskHelperFactory.getTaskIdSupplier())
            .withDescription(TASK_DESCRIPTION + captureRequest.getDisplayName())
            .withCaptureRequest(captureRequest)
            .withRecordId(captureRequest.getApplicationId())
            .withStatus(ManualModeState.ManualModeStatus.CREATED)
            .withConverterId(Preconditions.checkNotNull(ticketId))
            .build(), conversionsQueue, horizonUrl);
      _manualModeService = Preconditions.checkNotNull(manualModeService);
   }

   protected void initialize() throws TaskException {

      updateStatus(ManualModeState.ManualModeStatus.STARTING);
      // Invoke creation of the AppBuildRequest history record.
      try {
         Workpool wp = getTaskHelperFactory().getCachedWorkpool(
               getCaptureRequest().getWorkpoolId());

         // Create the AppBuildRequest record.
         createAppBuildRequest(
               wp,
               getCaptureRequest().getRuntimeId(),
               true);
      }
      catch (Exception e) {
         _log.error("Error loading workpool, skip AppBuildRequest." + e.getMessage(), e);
      }
   }

   /**
    * Do the work.
    * This is the reason for the task; use this method to perform the entire
    * operation. Tasks are run in threads, so this will not be called again.
    *
    * @throws com.vmware.appfactory.taskqueue.exception.TaskException
    *
    */
   @Override
   protected void doRun() throws TaskException {

      initialize();

      try {
         // Store the running stage for AppBuildRequest
         updateAppBuildRequestStage(RequestStage.running);

         lock.acquire();
         while (checkStatus()) {
            sleepUntilNextUpdate();

            if (getCurrentTaskState().isAborted()) {
               _manualModeService.cancel(getCurrentTaskState().getConverterId());
               updateAppBuildRequestStage(RequestStage.cancelled);
               cancel();
               break;
            }
         }
         // Store the successful stage for AppBuildRequest
         updateAppBuildRequestStage(RequestStage.successful);
      } catch(InterruptedException ex) {
         // Store the fail stage for AppBuildRequest
         updateAppBuildRequestStage(RequestStage.failed);
         notifyFailureAndUpdateApp(true);
         throw new TaskException(this, ex);
      } finally {
         lock.release();
      }

   }

   @Override
   protected void doCleanup() throws TaskException {
      // Cleanup project directory for non-complete tasks, fixes PR 718348
      doCleanupConversionTask(getCurrentTaskState().getStatus(),
            ManualModeState.ManualModeStatus.COMPLETE,
            getCurrentTaskState().getProjectId(),
            getCaptureRequest().getDisplayName());
   }

   /**
    * Create a new build by invoking MM and set a build's edit link.
    * @throws com.vmware.appfactory.taskqueue.exception.TaskException
    * If the conversion service fails to return a build ID for the newly-created build.
    */
   private void createBuild() throws TaskException {

      Status status = _manualModeService.checkStatus(getCurrentTaskState().getConverterId());
      Long buildId = null;

      // Get the project if the state is in refreshingProjectDone.
      if (status.getStates().contains(State.refreshingProjectDone)) {
         Project project = null;
         try {
            project = getTaskHelperFactory().getCws().getProjectStatus(status.getProjectId());
            buildId = createNewBuild(project, true);
         } catch (AfNotFoundException nfe) {
            throw new TaskException(this, "MM: Create build failed for projectId: " + status.getProjectId());
         } catch (Exception e) {
            /* Eat this exception */
            _log.error("Failed to load project, id: " + status.getProjectId(), e);
            throw new TaskException(this, String.format("MM: Failed to load project, id: %d. Current status: %s ",
                  status.getProjectId(), getCurrentTaskState()));
         }
         _log.debug("Creating new build for ticketId: {}, appId: {}", getCurrentTaskState().getConverterId(),
               getCaptureRequest().getApplicationId());
      } else {
         _log.error("Unexpected: Build state invalid. Current status: " + status.getCurrentState().toString());
         throw new TaskException(this, "Unexpected: Build states invalid. Current status: " + status.getCurrentState().toString());
      }
      if (buildId == null) {
         throw new TaskException(this, "MM: Failed to create a new build. Current status: " + getCurrentTaskState());
      }

      final Long buildIdFinal = buildId;
      updateState(new Function<ManualModeState.Builder, ManualModeState>() {
         @Override
         public ManualModeState apply(ManualModeState.Builder builder) {
            updateStatusAndLink(builder,
                  ManualModeState.ManualModeStatus.COMPLETE,
                  "/builds/edit/" + buildIdFinal);
            builder.withBuildId(buildIdFinal).withProgress(100);
            return builder.build();
         }
      });
   }

   /**
    * Cancel this running task.
    * Set the task status and disable the action link.
    */
   private void cancel() {
      /** Disable the link and clear the tooltip text */
      updateStatusAndLink(ManualModeState.ManualModeStatus.CANCELLED, null);
   }

   /**
    * Check current manual mode conversion status from VM.
    * @return true if the process is still running; return false otherwise.
    */
   private boolean checkStatus() throws TaskException {
      /* Assume manual mode process is running. */
      boolean isRunning = true;

      /* Get the build status from Manual mode */
      final Status mmStatus = _manualModeService.checkStatus(getCurrentTaskState().getConverterId());
      if (mmStatus == null) {
         /* Build project is already done and no longer available in the Manual mode queue. */
         return false;
      }

      /* Set the project ID if one is available */
      updateProjectId(mmStatus.getProjectId());

      final Status.State state = mmStatus.getCurrentState();
      String link = "/manualMode/index?appId=" + getCaptureRequest().getApplicationId()
         + "&ticketId=" + getCurrentTaskState().getConverterId();

      /* Map Manual mode state to ManualModeTask status */
      switch(state) {
         /** Handle cancel **/
         case cancelling:
         case cancelled:
            cancel();
            isRunning = false;
            break;
         /** Handle failure **/
         case installerDownloadFailed:
         case failure:
            updateStatus(ManualModeState.ManualModeStatus.FAILED);
            isRunning = false;
            break;
         /** Normal capture states **/
         case acquiringVm:
            updateStatusWithProgress(ManualModeState.ManualModeStatus.ACQUIRING_VM, 5);
            break;
         case vmAcquired:
            updateProgress(10);
            break;
         case poweringOnVm:
         case waitingForTools:
            updateStatusWithProgress(ManualModeState.ManualModeStatus.BUILDING, 15);
            break;
         case installingThinApp:
            updateProgress(18);
            break;
         case needsLoginWait:
         case preCaptureWait:
            updateStatusAndLinkWithProgress(ManualModeState.ManualModeStatus.WAITING_FOR_USER, link, 20);
            break;
         case takingPreCaptureSnapshot:
            updateStatusWithProgress(ManualModeState.ManualModeStatus.BUILDING, 50);
            break;
         case installationWait:
            updateStatusAndLinkWithProgress(ManualModeState.ManualModeStatus.WAITING_FOR_USER, link, 60);
            break;
         case installationDone:
            // Setting null is needed to disable the manual capture link.
            updateStatusAndLinkWithProgress(ManualModeState.ManualModeStatus.BUILDING, null, 80);
            break;
         case postInstallationWait:
         case postInstallationDone:
         case takingPostCaptureSnapshot:
            updateProgress(85);
            break;
         case refreshingProjectDone:
            updateStatusWithProgress(ManualModeState.ManualModeStatus.BUILDING, 90);
            break;
         case success:
         case finished:
         case vmReleased:
            createBuild();
            isRunning = false;
            break;
         /** States that share progress with others **/
         case needsLoginDone:
         case preCaptureDone:
         case downloading:
         case mountingFileSharesToGuest:
         case preInstallationWait:
         case preInstallationDone:
         case generatingProject:
         case preProjectBuildWait:
         case preProjectBuildDone:
         case buildingProject:
         case refreshingProject:
         case created:
            updateStatus(ManualModeState.ManualModeStatus.BUILDING);
      }

      return isRunning;
   }

   private void updateStatusAndLink(@Nonnull final ManualModeState.ManualModeStatus mmStatus,
                                    @Nullable final String link) {
      super.updateState(new Function<ManualModeState.Builder, ManualModeState>() {
         @Override
         public ManualModeState apply(ManualModeState.Builder builder) {
            updateStatusAndLink(builder, mmStatus, link);
            return builder.build();
         }
      });
   }

   private void updateStatusAndLinkWithProgress(
         @Nonnull final ManualModeState.ManualModeStatus mmStatus,
         @Nullable final String link, final int percent) {
      super.updateState(new Function<ManualModeState.Builder, ManualModeState>() {
         @Override
         public ManualModeState apply(ManualModeState.Builder builder) {
            updateStatusAndLink(builder, mmStatus, link);
            return builder.withProgress(percent).build();
         }
      });
   }

   private static void updateStatusAndLink(
         @Nonnull ManualModeState.Builder builder,
         @Nonnull ManualModeState.ManualModeStatus mmStatus,
         @Nullable String link) {
      builder.withStatus(mmStatus).withStatusLink(link);
   }

   private void updateProjectId(@Nullable final Long projectId) {
      super.updateState(new Function<ManualModeState.Builder, ManualModeState>() {
         @Override
         public ManualModeState apply(ManualModeState.Builder builder) {
            return builder.withProjectId(projectId).build();
         }
      });
   }
}
