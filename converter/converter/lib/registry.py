# VMware ThinApp Factory
# Copyright (c) 2009-2013 VMware, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import base64
import binascii
import codecs
import re
import struct
import time
import logging

from collections import namedtuple
from pyparsing import oneOf, Literal, restOfLine, ZeroOrMore, White, Group, Optional

log = logging.getLogger(__name__)

### Define a parser for the registry format using pyparsing

### Simple keyword enumerations
### For isolationMode, strip the leading isolation_ prefix
isolationMode = oneOf(['isolation_full',
                       'isolation_merged',
                       'isolation_writecopy',
                       'isolation_sb_only']).setResultsName('isolationMode').setParseAction(lambda orig, match, tokens: tokens[0].replace('isolation_', ''))

regType = oneOf(['REG_NONE',
                 'REG_SZ',
                 'REG_EXPAND_SZ',
                 'REG_BINARY',
                 'REG_DWORD',
                 'REG_DWORD_BIG_ENDIAN',
                 'REG_LINK',
                 'REG_MULTI_SZ',
                 'REG_RESOURCE_LIST',
                 'REG_FULL_RESOURCE_DESCRIPTOR',
                 'REG_RESOURCE_REQUIREMENTS_LIST',
                 'REG_QWORD']).setResultsName('regType')

# Transforms the ~ or = into True or False.
equals = oneOf(['~', '=']).setParseAction(lambda orig, match, tokens: tokens[0] == '~')

# Example:
# Value=Foobar
# REG_SZ~Foobaz#2300
valueLine = Group(Literal(u'Value').suppress() + \
            equals.setResultsName('nameExpand') + \
            Optional(restOfLine.setResultsName('name') + \
            regType + equals.setResultsName('dataExpand') + \
            restOfLine.setResultsName('data')))

# A key can have many values in a row or none at all.
values = ZeroOrMore(valueLine).setResultsName('values')

# A full entry looks like this:
# isolation_writecopy HKLM\Blah
#    Value=(... as above ...)
entry = isolationMode + White().suppress() + \
        restOfLine.setResultsName('path') + values

### Data types generated by ImportRegistry

class RegistryDataError(Exception):
   pass

RegistryValue = namedtuple('RegistryValue', 'name data regType nameExpand dataExpand')

class RegistryKey(object):
   def __init__(self, path, isolation, intermediate, subkeys=None, values=None):
      self.subkeys = subkeys or dict()
      self.values = values or dict()
      self.path = path
      self.isolation = isolation
      self.intermediate = intermediate

   def __str__(self):
      return """<%s: '%s'
 subkeys: %s,
 values: %s>""" % (self.__class__.__name__, self.path, self.subkeys.keys(), repr(self.values))

   def __repr__(self):
      return "%s(path='%s', isolation='%s', intermediate=%s, subkeys=%s, values=%s)" % \
             (self.__class__.__name__, self.path,
             repr(self.isolation), repr(self.intermediate),
             repr(self.subkeys), repr(self.values))

   def find(self, path):
      dirs = path.split('\\')

      iterKey = self
      for d in dirs:
         if d in iterKey.subkeys:
            iterKey = iterKey.subkeys[d]
         else:
            raise LookupError('No such path %s in %s' % (path, self))

      return iterKey

def ImportRegistry(f):
   """
      Import registry data from a filestream f and return a RegistryKey hive.
   """
   root = RegistryKey('', 'full', True)

   # The approach that follows is a bit convoluted. Ideally we would walk
   # the registry hierarchy but we don't have that hierarchy yet, we are
   # building it as we go. So the only thing we can safely hang our hat on
   # is that vregtool output is ordered such that if HKEY/A/B/C and
   # HKEY/A/B/C/D both exist, the former will be encountered first.
   keyStack = []

   allKeys = {'': root}

   for parseKey in _ProcessRegistryText(f):
      # First, if the key already exists, then just update it.
      if parseKey['path'] in allKeys:
         existingKey = allKeys[parseKey['path']]

         if 'values' in parseKey:
            for v in parseKey['values']:
               newValue = RegistryValue(**v)
               # Bug: 857275#c6 - Fail only if previously loaded value is not the same.
               # This assert ensures reg entries having different values for same keys
               # will not be entertained by TAF.
               assert existingKey.values[v['name']] == newValue
               existingKey.values[v['name']] = newValue

         continue

      # Otherwise, break down the path into components. Walk the tree until a
      # subcomponent does not exist.
      dirs = parseKey['path'].split('\\')

      # Compare the stack to our current set of paths.
      # zip implicitly slices the array down to the largest common length
      # which is good for this procedure.
      commonLen = 0
      for compare in zip(keyStack, dirs):
         # LHS is a keyStack entry which is a (component, RegistryKey) tuple
         (left, key), right = compare

         if left == right:
            commonLen += 1
         else:
            break

      # Pop everything that will no longer ever be touched (including
      # the leaf nodes we created earlier.) Fast forward dirs to where
      # node creation will continue. Begin iteration with the key at the
      # tip of the common path prefix.
      partialPath = '\\'.join(dirs[:commonLen])
      dirs = dirs[commonLen:]
      keyStack = keyStack[:commonLen]

      if len(keyStack) > 0:
         iterKey = keyStack[-1][1]
      else:
         iterKey = root

      # Handle all remaining directories here.
      for d in dirs:
         # ntpath.join breaks on forward slashes... resort to more
         # primitive methods instead.
         if partialPath == '':
            partialPath = d
         else:
            partialPath = '\\'.join([partialPath, d])

         if d in iterKey.subkeys:
            iterKey = iterKey.subkeys[d]
         elif partialPath == parseKey['path']:
            # Create a key for the leaf node.
            newKey = RegistryKey(parseKey['path'], parseKey['isolationMode'], False)
            allKeys[parseKey['path']] = newKey

            if 'values' in parseKey:
               for v in parseKey['values']:
                  newValue = RegistryValue(**v)
                  newKey.values[v['name']] = newValue

            iterKey.subkeys[d] = newKey
            keyStack.append((d, newKey))
         else:
            # Intermediate key. Note that isolation mode is inherited.
            intKey = RegistryKey(partialPath, parseKey['isolationMode'], True)
            allKeys[partialPath] = intKey

            keyStack.append((d, intKey))
            iterKey.subkeys[d] = intKey
            iterKey = intKey

   return root

def ExportRegistry(root, stream):
   """
      Takes a RegistryKey hive and dumps it back into a file.
      Note that the caller is responsible for opening the stream
      with UTF-16-LE behavior.
   """

   # Write a comment to distinguish this from the pristine version
   stream.write('# Generated by Converter Web Service at %s\r\n' % \
                time.asctime())

   # We must read in depth-first order, so we must also write in depth-first
   # order.
   def walker(node):
      if not node.intermediate:
         stream.write('isolation_%s %s\r\n' % (node.isolation, node.path))

         for name in sorted(node.values.keys()):
            exported = node.values[name]

            if exported.dataExpand:
               dataEquals = '~'
            else:
               dataEquals = '='

            if exported.nameExpand:
               nameEquals = '~'
            else:
               nameEquals = '='

            stream.write('  Value%c%s\r\n' % (nameEquals, exported.name))
            stream.write('  %s%c%s\r\n' % (exported.regType, dataEquals, exported.data))

         stream.write('\r\n')

      for sub in sorted(node.subkeys.keys()):
         walker(node.subkeys[sub])

   walker(root)

def InterpretData(regType, data, dataExpand):
   """
      Returns the most sensible interpretation of a registry binary blob
      according to its registry type. Here is the mapping:

      REG_SZ                  UTF-8 string
      REG_EXPAND_SZ           UTF-8 string
      REG_MULTI_SZ            Array of UTF-8 strings
      REG_DWORD               Integer
      REG_DWORD_BIG_ENDIAN    Integer
      REG_QWORD               Integer
      REG_BINARY              Array of integers
      Everything else         Uninterpreted Base64 bytestring
   """

   NUL = u'\x00'

   # XXX: A stopgap measure for trimming the trailing NUL until we have a
   # comprehensive, lossless way to unescape strings.
   if dataExpand:
      TA_NUL = '#2300'
   else:
      TA_NUL = '#00'

   if regType in ('REG_EXPAND_SZ', 'REG_SZ'):
      # Minimal processing to avoid data loss. Simply strip the trailing
      # #2300 from the string since all REG_SZ and REG_EXPAND_SZ values
      # must have it.
      assert data.endswith(TA_NUL), '%s does not end with %s' % (data, TA_NUL)
      return data[:-len(TA_NUL)]
   elif regType == 'REG_MULTI_SZ':
      # Return an array of strings; do not process the inner strings,
      # just strip their NULs and put them into the array.
      # Ends with two UCS-2 nul characters.
      terminator = TA_NUL + TA_NUL
      if not data.endswith(terminator):
         raise RegistryDataError('Unexpected data "%s" for REG_MULTI_SZ' % \
                                 data)
      return data[:-len(terminator)].split(TA_NUL)
   else:
      data = _UnescapeBinary(data)

      if regType in ('REG_DWORD', 'REG_DWORD_LITTLE_ENDIAN'):
         if len(data) != 4:
            raise RegistryDataError('Unexpected length %d for %s data "%s"' % \
                                    (len(data), regType, data))
         return struct.unpack('<I', data)[0]
      elif regType == 'REG_DWORD_BIG_ENDIAN':
         if len(data) != 4:
            raise RegistryDataError('Unexpected length %d for %s data "%s"' % \
                                    (len(data), regType, data))
         return struct.unpack('>I', data)[0]
      elif regType == 'REG_QWORD':
         if len(data) != 8:
            raise RegistryDataError('Unexpected length %d for %s data "%s"' % \
                                    (len(data), regType, data))
         return struct.unpack('<Q', data)[0]
      elif regType == 'REG_BINARY':
         return [ord(i) for i in data]
      else:
         # data is already a bytestring.
         return base64.b64encode(data)

def SerializeData(regType, interpData, dataExpand):
   """
      The exact opposite of InterpretData. Takes interpreted data such as
      the kind returned by InterpretData and returns the binary blob
      equivalent.
   """

   if dataExpand:
      NUL = '#2300'
   else:
      NUL = '#00'

   if regType in ('REG_EXPAND_SZ', 'REG_SZ'):
      return interpData + NUL
   elif regType == 'REG_MULTI_SZ':
      return NUL.join(interpData) + NUL + NUL
   else:
      if regType in ('REG_DWORD', 'REG_DWORD_LITTLE_ENDIAN'):
         data = struct.pack('<I', interpData)
      elif regType == 'REG_DWORD_BIG_ENDIAN':
         data = struct.pack('>I', interpData)
      elif regType == 'REG_QWORD':
         data = struct.pack('<Q', interpData)
      elif regType == 'REG_BINARY':
         data = ''.join([chr(i) for i in interpData])
      else:
         data = base64.b64decode(interpData)

      return _EscapeBinary(data)

def _EscapeBinary(s):
   # Singly-escape all low-order bytes.
   escaped = u''
   for c in s:
      escaped += '#%s' % binascii.b2a_hex(c)
   return escaped

def _UnescapeBinary(data):
   i = 0
   blob = bytearray()

   while i < len(data):
      if data[i] == u'#':
         # Snarf the next two characters and turn them into a single byte.
         char = chr(int(data[i+1:i+3], 16))
         blob.extend(char)

         i += 2
      i += 1

   return bytes(blob)

def _ProcessRegistryText(f):
   # f is likely to be a file opened with codecs.open, which means it must
   # be opened in binary mode, which means newlines cannot be removed with
   # 'U' mode. pyparsing is also stupid and cannot be told to expect CR+LF.
   # Thus, we need to preprocess the stream first by removing newlines. Then,
   # we parseString each individual entry.
   buf = ''
   while True:
      line = f.readline()
      if line.startswith('#'):
         # Ignore comments.
         continue
      if line == '':
         break
      elif line == '\r\n':
         if (not re.match("^[ \n]*$", buf)):
            # parse buf only if its not made up of empty lines/spaces.
            parsed = entry.parseString(buf)
            yield parsed
         buf = ''
      else:
         buf += line.replace('\r\n', '\n')

if __name__ == '__main__':
   # Testing only
   import codecs
   import sys
   f = codecs.open(sys.argv[1], 'r', 'utf-16')
   g = codecs.open(sys.argv[1] + '.new', 'w', 'utf-16')

   hive = ImportRegistry(f)
   ExportRegistry(hive, g)

   import code
   code.interact(local=locals())
